// NOTE replace deficient built-in publishing plugin with nebula-publishing,
// which does a better job generating the POM and properly aggregates signature files for upload to Bintray
apply plugin: 'maven'
apply plugin: 'maven-publish'

ext.pom = file("$buildDir/publications/jars/pom-default.xml")
ext.signedPom = file("$buildDir/publications/jars/pom-default.xml.asc")

if ( !project.hasProperty('skip.signing') ){
    apply plugin: 'signing'

    signing {
        sign configurations.archives
    }

    if ( !signing.signatory ) {
        logger.warn "No Signatory configured for project $project.name. Skip signing! See https://docs.gradle.org/current/userguide/signing_plugin.html"
        signArchives.enabled = false
        ext."skip.signing" = true
    }

    task signPom(type: Sign) {
        group "publishing"
        description "Sign the projects pom file"

        inputs.file pom
        outputs.file signedPom

        doLast{

            def input = pom.newInputStream()
            def output = signedPom.newOutputStream()
            try{
                signatory.sign(input, output)
            }
            catch (Exception e){
                logger.error e.message
            }
            finally {
                input.close()
                output.close()
            }
        }
    }

    /**
     * The signPom Task depends on the GenerateMavenPom task which gets dynamically added
     * with a name derived from a publication. In our case 'jars'.
     *
     * Our jars publication registers the signed pom as artifact.
     * If the task does not run before publishJarsPublicationToMavenLocal this task will fail.
     */
    tasks.whenTaskAdded {

        switch (it.name) {
            case "generatePomFileForJarsPublication":
                signPom.dependsOn it
                break
            case "publishJarsPublicationToMavenLocal":
                it.dependsOn signPom
                break
        }
    }
}

def projectMeta = {
    resolveStrategy = groovy.lang.Closure.DELEGATE_FIRST
    name project.name
    description project.description
    url 'https://github.com/asciidoctor/asciidoctorj'
    inceptionYear '2013'
    licenses {
        license {
            name 'The Apache Software License, Version 2.0'
            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
            distribution 'repo'
        }
    }
    issueManagement {
        system 'github'
        url 'https://github.com/asciidoctor/asciidoctorj/issues'
    }
    scm {
        url 'https://github.com/asciidoctor/asciidoctorj'
    }
    developers {
        developer {
            id 'asotobu'
            name 'Alex Soto Bueno'
            email 'asotobu@gmail.com'
            timezone '1'
            roles {
                role 'Project Lead'
            }
        }
        developer {
            id 'mojavelinux'
            name 'Dan Allen'
            email 'dan.j.allen@gmail.com'
            timezone '-7'
            roles {
                role 'Contributor'
            }
        }
        developer {
            id 'abelsromero'
            name 'Abel Salgado Romero'
            email 'abelromero@gmail.com'
            timezone '1'
            roles {
                role 'Contributor'
            }
        }
    }
}

publishing {
    publications {
        jars(MavenPublication) {

            // NOTE only build sources and javadoc jars when releasing
            if (project.statusIsRelease) {
                if (project.tasks.withType(Jar).findByName('sourcesJar')) {
                    artifact sourcesJar
                }
                if (project.tasks.withType(Jar).findByName('javadocJar')) {
                    artifact javadocJar
                }

                // register the signed pom file
                // signedPom is an output file from the signPom task
                if ( !project.hasProperty('skip.signing') ) {
                    artifact(signedPom) {
                        extension = "pom.asc"
                        classifier = null
                    }
                }
            }

            pom.withXml {
                asNode().children().last() + projectMeta
            }

            if ( !project.isDistribution() ) {
                from components.java
            }
        }

    }
}


// QUESTION should we move manifest creation to general Java plugin config?
jar {
  manifest {
    attributes \
      'Built-By': System.properties['user.name'],
      'Created-By': "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})".toString(),
      'Build-Date': buildDateOnly,
      //'Build-Time': buildTimeOnly,
      //'Specification-Title': project.name,
      //'Specification-Version': project.version,
      //'Specification-Vendor': 'asciidoctor.org',
      'Implementation-Title': project.name,
      'Implementation-Version': project.version,
      'Implementation-Vendor': 'asciidoctor.org'
  }
}
